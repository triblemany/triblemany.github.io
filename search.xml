<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>阻抗串并转换</title>
      <link href="/archives/abd732af/series-parallel-conversion.html"/>
      <url>/archives/abd732af/series-parallel-conversion.html</url>
      
        <content type="html"><![CDATA[<p>本文介绍了串联和并联电路的转换，以及Q值的计算。</p><a id="more"></a><h2 id="串并联转换"><a href="#串并联转换" class="headerlink" title="串并联转换"></a>串并联转换</h2><h3 id="串联-gt-并联"><a href="#串联-gt-并联" class="headerlink" title="串联-&gt;并联"></a>串联-&gt;并联</h3><p><img src="series-parallel-conversion/series-to-parallel.svg" alt="series-to-parallel"></p><script type="math/tex; mode=display">Q=\frac{X_s}{R_s}\\R_p=(1+Q^2)R_s\\X_p=X_s\left(1+\frac{1}{Q^2}\right)</script><h3 id="并联-gt-串联"><a href="#并联-gt-串联" class="headerlink" title="并联-&gt;串联"></a>并联-&gt;串联</h3><p><img src="series-parallel-conversion/parallel-to-series.svg" alt="parallel-to-series"></p><script type="math/tex; mode=display">Q=\frac{R_p}{X_p}\\R_s=\frac{R_p}{(1+Q^2)}\\X_s=\frac{X_p}{\left(1+\frac{1}{Q^2}\right)}</script><h2 id="带有Q值的L和带有Q值的C谐振"><a href="#带有Q值的L和带有Q值的C谐振" class="headerlink" title="带有Q值的L和带有Q值的C谐振"></a>带有Q值的L和带有Q值的C谐振</h2><p>谐振网络的Q值为</p><script type="math/tex; mode=display">\frac{1}{Q}=\frac{1}{Q_L}+\frac{1}{Q_C}</script><h2 id="理论推导"><a href="#理论推导" class="headerlink" title="理论推导"></a>理论推导</h2><p>这里包含上面三个结论的理论推导。</p><h3 id="并联-gt-串联-1"><a href="#并联-gt-串联-1" class="headerlink" title="并联-&gt;串联"></a>并联-&gt;串联</h3><p><img src="series-parallel-conversion/series-parallel.svg" alt="series-parallel"></p><p>推导如下</p><script type="math/tex; mode=display">\begin{aligned}R_s+jX_s&=\frac{1}{\frac{1}{R_p}+\frac{1}{jX_p}}\\&=\frac{R_pX_p^2}{R_p^2+X_p^2}+j\frac{R_p^2X_p}{R_p^2+X_p^2}\\&=\frac{R_p}{(1+Q^2)}+j\frac{X_p}{\left(1+\frac{1}{Q^2}\right)}\end{aligned}</script><p>相应的，交换顺序可得串联-&gt;并联。</p><h3 id="实际并联LC网络的Q值"><a href="#实际并联LC网络的Q值" class="headerlink" title="实际并联LC网络的Q值"></a>实际并联LC网络的Q值</h3><p>考虑一个具有Q值的电感和电容的并联谐振，其中电感常用串联LR模型，电容常用并联CR模型。</p><p><img src="series-parallel-conversion/shunt-rlc-Q.svg" alt="shunt-rlc-Q"></p><p>计算这个网络的等效Q值时，首先将串联的LR转换为等效并联LR，有</p><script type="math/tex; mode=display">R_{s,p}=R_s(1+Q_L^2)\\L_{s,p}=L_s\left(1+\frac{1}{Q_L^2}\right)</script><p>将两个电阻并联，有</p><script type="math/tex; mode=display">R_{s,p||p}=\frac{1}{\frac{1}{R_{s,p}}+\frac{1}{R_p}}</script><p>于是整体Q值为</p><script type="math/tex; mode=display">\begin{aligned}Q&=\omega C_pR_{s,p||p}\\&=\frac{\omega C_p}{\frac{1}{R_{s,p}}+\frac{1}{R_p}}\\&=\frac{1}{\frac{1}{\omega C_pR_{s,p}}+\frac{1}{Q_C}}\\&=\frac{1}{\frac{\omega L_{s,p}}{R_{s,p}}+\frac{1}{Q_C}}\\&=\frac{1}{\frac{1}{Q_L}+\frac{1}{Q_C}}\\\end{aligned}</script><p>也即</p><script type="math/tex; mode=display">\frac{1}{Q}=\frac{1}{Q_L}+\frac{1}{Q_C}</script><p>值得注意的是，其中的$\omega$定义为</p><script type="math/tex; mode=display">\omega=\frac{1}{\sqrt{L_{s,p}C_p}}=\frac{\sqrt{1-\frac{C_pR_s^2}{L_s}}}{\sqrt{L_{s}C_p}}\approx\frac{1}{\sqrt{L_{s}C_p}}</script><p>当串联电阻较小时可以简化为最后一项。</p><h3 id="实际串联LC网络的Q值"><a href="#实际串联LC网络的Q值" class="headerlink" title="实际串联LC网络的Q值"></a>实际串联LC网络的Q值</h3><p>另考虑一个具有Q值的电感和电容的串联谐振。</p><p><img src="series-parallel-conversion/series-rlc-Q.svg" alt="series-rlc-Q"></p><p>计算这个网络的等效Q值时，首先将并联LC转换为等效串联的LC，有</p><script type="math/tex; mode=display">R_{p,s}=\frac{R_p}{(1+Q_C^2)}\\C_{p,s}=C_p\left(1+\frac{1}{Q_C^2}\right)</script><p>将两个电阻串联，有</p><script type="math/tex; mode=display">R_{p,s+s}=R_s+R_{p,s}</script><p>于是整体Q值为</p><script type="math/tex; mode=display">\begin{aligned}Q&=\frac{\omega L_s}{R_s+R_{p,s}}\\&=\frac{1}{\frac{1}{Q_L}+\frac{R_{p,s}}{\omega L_s}}\\&=\frac{1}{\frac{1}{Q_L}+\omega C_{p,s}R_{p,s}}\\&=\frac{1}{\frac{1}{Q_L}+\frac{1}{Q_C}}\\\end{aligned}</script><p>也即</p><script type="math/tex; mode=display">\frac{1}{Q}=\frac{1}{Q_L}+\frac{1}{Q_C}</script><p>此时，$\omega$定义为</p><script type="math/tex; mode=display">\omega=\frac{1}{\sqrt{L_{s}C_{p,s}}}=\frac{\sqrt{1-\frac{L_s}{C_pR_p^2}}}{\sqrt{L_{s}C_p}}\approx\frac{1}{\sqrt{L_{s}C_p}}</script><p>当并联电阻较大时可以简化为最后一项。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Circuit Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用ADS创建电感Pcell</title>
      <link href="/archives/1e678d19/ads-inductor-pcell.html"/>
      <url>/archives/1e678d19/ads-inductor-pcell.html</url>
      
        <content type="html"><![CDATA[<p>电感是射频集成电路设计中的基础原件，也是变压器的构成部分。通常，电感越接近圆形其面积(磁通量，电感)/边长(串联损耗)比越高，因而Q值越高。但在CMOS工艺下，有时只允许使用直线和45°折线，因此设计时多数退而求其次绘制八边形电感。绘制八边形电感由于需要处理边角和格点，十分繁琐，因此可以通过编写程序省去这部分重复性工作。本文介绍了一种基于ADS AEL语言的电感Pcell设计方法。</p><a id="more"></a><h2 id="预备"><a href="#预备" class="headerlink" title="预备"></a>预备</h2><p>AEL绘制多边形的语法为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">decl coors = list(</span><br><span class="line">list(0, 0),</span><br><span class="line">list(2, 0),</span><br><span class="line">list(2, 2),</span><br><span class="line">list(0, 2),</span><br><span class="line">list(0, 0)</span><br><span class="line">);</span><br><span class="line">decl newPolygon = db_create_primitive_polygon(coors);</span><br><span class="line">db_create_polygon(context, layerM1, newPolygon);</span><br></pre></td></tr></table></figure><p>上面的代码先定义了一个坐标的列表，列表中的每个元素代表多边形一个顶点。每个顶点又由一个2个元素的列表<code>list(x, y)</code>构成，分别代表为x、y的坐标。因此，上面的代码绘制了一个左下角在<code>(0, 0)</code>的边长为2的正方形。之后，先使用<code>db_create_primitive_polygon</code>将其创建成为原始多边形，再增加层信息后使用<code>db_create_polygon</code>将原始多边形加入设计数据库。</p><p>由于AEL不支持类型，对坐标进行修改只能通过函数进行。值得注意的是，AEL中列表的赋值是引用传递，因此当使用<code>decl coors2 = coors;</code>后，<code>coors2</code>和<code>coors</code>指向同一个位置，对其中之一修改也会影响到另一个。我们设计了一个函数对多边形进行整体平移和翻转：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">defun adjust(l, xc, yc, x, y)</span><br><span class="line">&#123;</span><br><span class="line">decl i = 0;</span><br><span class="line">decl len = listlen( l );//获得列表长度</span><br><span class="line">for( i = 0; i &lt; len; i++ )//遍历列表</span><br><span class="line">&#123;</span><br><span class="line">//生成平移和翻转后的坐标，由于采用了垃圾回收机制，新生成的列表t不是局部变量</span><br><span class="line">decl t = list(l[i][0] * xc + x, l[i][1] * yc + y);</span><br><span class="line">//替换原有元素</span><br><span class="line">repla(l, t, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它接受5个参数，第1个是列表，第2、3个分别是x、y的缩放系数，第4、5个是x、y的平移系数。</p><p>此外，为了防止设计的版图顶点不在格点上，我们附加了<code>grid_ceil2</code>和<code>grid_floor2</code>两个相对格点取整的函数，他们以微米为单位对0.01取整。</p><h2 id="交错部分设计"><a href="#交错部分设计" class="headerlink" title="交错部分设计"></a>交错部分设计</h2><p>此部分由函数<code>create_crossing</code>实现。</p><p>首先计算几个常用量，由</p><script type="math/tex; mode=display">\tan(2\theta)=\frac{2\tan(\theta)}{1-\tan^2(\theta)}</script><p>可以算得</p><script type="math/tex; mode=display">\tan(22.5^\circ)=\sqrt{2}-1</script><p>考虑版图</p><p><img src="ads-inductor-pcell/crossing.svg" alt="crossing"></p><p>可以计算出各点的位置</p><div class="table-container"><table><thead><tr><th style="text-align:center">位置</th><th style="text-align:center">坐标</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">（ -t, 0 ）</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">( -(w + s - e) / 2, 0 )</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">( (w + s + e) / 2, w + s )</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">( t, w + s )</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">( t, 2w + s )</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">( (w + s - e) / 2, 2w + s )</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">( -(w + s + e) / 2, w )</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">( -t, w )</td></tr></tbody></table></div><p>其中$e=(\sqrt{2}-1)w$，相反方向的可以通过<code>adjust</code>函数实现。</p><h2 id="线圈边缘设计"><a href="#线圈边缘设计" class="headerlink" title="线圈边缘设计"></a>线圈边缘设计</h2><p>此部分由函数<code>create_coil</code>实现。</p><p>线圈边缘如图</p><p><img src="ads-inductor-pcell/coil.svg" alt="coil"></p><p>对应坐标为</p><div class="table-container"><table><thead><tr><th style="text-align:center">位置</th><th style="text-align:center">坐标</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">( t, Dh + Dd - w )</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">( Dw - e &lt; Dw + Dd - w ? Dw - e : Dw + Dd - w, Dh + Dd - w )</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">( Dw + Dd - w, Dh - e &lt; Dh + Dd - w ? Dh - e : Dh + Dd - w )</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">( Dw + Dd - w, -Dh + e &gt; -Dh - Dd + w ? -Dh + e : -Dh - Dd + w )</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">( Dw - e &lt; Dw + Dd - w ? Dw - e : Dw + Dd - w, - Dh - Dd + w )</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">( t, - Dh - Dd + w )</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">( t, - Dh - Dd )</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">( Dw, - Dh - Dd )</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">( Dw + Dd, - Dh )</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">( Dw + Dd, Dh )</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">( Dw, Dh + Dd )</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">( t, Dh + Dd )</td></tr></tbody></table></div><p>相反方向的可以通过<code>adjust</code>函数实现。</p><h2 id="延展设计"><a href="#延展设计" class="headerlink" title="延展设计"></a>延展设计</h2><p>此部分由函数<code>create_tj</code>实现。</p><p>延展部分和交错部分非常相似，其特殊之处在于两侧可宽度不同</p><p><img src="ads-inductor-pcell/extension.svg" alt="coil"></p><p>为了使图形尽可能平衡，令上、下的内侧长度均为$a_l$，中间线宽为两侧均值，有</p><script type="math/tex; mode=display">\begin{aligned}a_l+a_r+(s_2-s_1)&=e\\w_1+\frac{a_r-a_l-(\sqrt{2}-1)w_1}{\sqrt{2}}&=\frac{w_1+w_2}{2}\end{aligned}</script><p>由此可解出各点坐标。</p><h2 id="多圈绘制"><a href="#多圈绘制" class="headerlink" title="多圈绘制"></a>多圈绘制</h2><p>此部分由函数<code>create_diff_inductor</code>实现。</p><p>其核心在于计算每圈的Dw, Dd, Dh，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">decl ew = grid_ceil2( W * (sqrt(2) - 1) );</span><br><span class="line">decl es = grid_ceil2( S * (sqrt(2) - 1) );</span><br><span class="line">decl newDw = grid_floor2( Dw - ew - es );</span><br><span class="line">decl newDh = grid_floor2( Dh - ew - es );</span><br><span class="line">decl newDd = grid_floor2( Dd - W - S + ew + es );</span><br><span class="line">// 支持矩形电感</span><br><span class="line">if(newDd &lt; 0)</span><br><span class="line">&#123;</span><br><span class="line">    newDw = newDw + newDd;</span><br><span class="line">    newDh = newDh + newDd;</span><br><span class="line">    newDd = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>绘制出的电感如下图</p><p><img src="ads-inductor-pcell/ind.png" alt="ind" style="zoom:50%;"></p><p>可以看出，其具有电感的完整功能，且各部分可调。同时也可以支持矩形（RD=0）或者矩形/八边形混合电感（RD较小）。</p><p><img src="ads-inductor-pcell/ind_square.png" alt="ind_square" style="zoom: 50%;"></p><p>此外，将两个电感组合起来，也可以轻松实现变压器。</p><p><img src="ads-inductor-pcell/transformer.png" alt="transformer" style="zoom: 50%;"></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>完整代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line">load(&quot;vias.ael&quot;);</span><br><span class="line"></span><br><span class="line">defun grid_ceil2(input)</span><br><span class="line">&#123;</span><br><span class="line">return ceil(100*input)/100.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defun grid_floor2(input)</span><br><span class="line">&#123;</span><br><span class="line">return floor(100*input)/100.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defun adjust(l, xc, yc, x, y)</span><br><span class="line">&#123;</span><br><span class="line">decl i = 0;</span><br><span class="line">decl len = listlen( l );</span><br><span class="line">for( i = 0; i &lt; len; i++ )</span><br><span class="line">&#123;</span><br><span class="line">decl t = list(l[i][0] * xc + x, l[i][1] * yc + y);</span><br><span class="line">repla(l, t, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defun create_crossing(context, layerM1, w, s, t, x, y, xc, yc)</span><br><span class="line">&#123;</span><br><span class="line">e = grid_ceil2( w * (sqrt(2) - 1) );</span><br><span class="line">decl x1 = (w + s - e) / 2.0;</span><br><span class="line">decl x2 = (w + s + e) / 2.0;</span><br><span class="line">decl coors = list(</span><br><span class="line">list(- t, 0),</span><br><span class="line">list(- x1 , 0),</span><br><span class="line">list(x2, w + s),</span><br><span class="line">list(t, w + s),</span><br><span class="line">list(t, 2 * w + s),</span><br><span class="line">list(x1, 2 * w + s),</span><br><span class="line">list(- x2, w),</span><br><span class="line">list(- t, w),</span><br><span class="line">list(- t, 0)</span><br><span class="line">);</span><br><span class="line">adjust(coors, xc, yc, x, y);</span><br><span class="line">decl newPolygon = db_create_primitive_polygon(coors);</span><br><span class="line">db_create_polygon(context, layerM1, newPolygon);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defun create_coil(context, layerM, Dw, Dh, Dd, w, t, x, y)</span><br><span class="line">&#123;</span><br><span class="line">decl e = grid_ceil2( w * (sqrt(2) - 1) );</span><br><span class="line">decl coors = list(</span><br><span class="line">list(t, Dh + Dd - w),</span><br><span class="line">list(Dw - e &lt; Dw + Dd - w ? Dw - e : Dw + Dd - w, Dh + Dd - w),</span><br><span class="line">list(Dw + Dd - w, Dh - e &lt; Dh + Dd - w ? Dh - e : Dh + Dd - w),</span><br><span class="line">list(Dw + Dd - w, -Dh + e &gt; -Dh - Dd + w ? -Dh + e : -Dh - Dd + w),</span><br><span class="line">list(Dw - e &lt; Dw + Dd - w ? Dw - e : Dw + Dd - w, - Dh - Dd + w),</span><br><span class="line">list(t, - Dh - Dd + w),</span><br><span class="line">list(t, - Dh - Dd),</span><br><span class="line">list(Dw, - Dh - Dd),</span><br><span class="line">list(Dw + Dd, - Dh),</span><br><span class="line">list(Dw + Dd, Dh),</span><br><span class="line">list(Dw, Dh + Dd),</span><br><span class="line">list(t, Dh + Dd),</span><br><span class="line">list(t, Dh + Dd - w)</span><br><span class="line">);</span><br><span class="line">adjust(coors, 1, 1, x, y);</span><br><span class="line">decl newPolygon = db_create_primitive_polygon(coors);</span><br><span class="line">db_create_polygon(context, layerM, newPolygon);</span><br><span class="line"></span><br><span class="line">adjust(coors, -1, 1, 0, 0);</span><br><span class="line">decl newPolygon2 = db_create_primitive_polygon(coors);</span><br><span class="line">db_create_polygon(context, layerM, newPolygon2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defun create_tj(context, layerM, w1, s1, t, w2, s2, e, x, y, dir)</span><br><span class="line">&#123;</span><br><span class="line">decl d = s2 - s1;</span><br><span class="line">decl ar = grid_floor2( 0.5 * ( sqrt(2)/2 * (w1 + w2) - w1 +e - s2 + s1 ) );</span><br><span class="line">decl al = e - ar - s2 + s1;</span><br><span class="line">decl coors = list(</span><br><span class="line">list(-t, 0),</span><br><span class="line">list(-s1, 0),</span><br><span class="line">list(-s1, -w1 - ar),</span><br><span class="line">list(-s2, -w1 - ar - (s2-s1)),</span><br><span class="line">list(-s2, -w1 - e),</span><br><span class="line">list(-s2 - w2, -w1 - e),</span><br><span class="line">list(-s2 - w2, -w1 - al - (w2+s2-w1-s1)),</span><br><span class="line">list(-s1 - w1, -w1 - al),</span><br><span class="line">list(-s1 - w1, -w1),</span><br><span class="line">list(-t, -w1),</span><br><span class="line">list(-t, 0)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">db_create_pin(context, x-s2-w2/2, pow(-1, dir)*(y+e+w1), pow(-1, dir)*90, layerM);</span><br><span class="line">db_create_pin(context, x+s2+w2/2, pow(-1, dir)*(y+e+w1), pow(-1, dir)*90, layerM);</span><br><span class="line"></span><br><span class="line">adjust(coors, 1, pow(-1, dir+1), x, pow(-1, dir)*y);</span><br><span class="line">decl newPolygon = db_create_primitive_polygon(coors);</span><br><span class="line">db_create_polygon(context, layerM, newPolygon);</span><br><span class="line"></span><br><span class="line">adjust(coors, -1, 1, 0, 0);</span><br><span class="line">decl newPolygon2 = db_create_primitive_polygon(coors);</span><br><span class="line">db_create_polygon(context, layerM, newPolygon2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defun create_diff_inductor(context, MT, MB, D, W, S, C, RH, RD, s1, w2, s2, e, x, y, dir, combine)</span><br><span class="line">&#123;</span><br><span class="line">decl AP = db_get_layerid(context, &quot;AP&quot;, &quot;drawing&quot;);</span><br><span class="line">decl M9 = db_get_layerid(context, &quot;M9&quot;, &quot;drawing&quot;);</span><br><span class="line">decl M8 = db_get_layerid(context, &quot;M8&quot;, &quot;drawing&quot;);</span><br><span class="line">decl M7 = db_get_layerid(context, &quot;M7&quot;, &quot;drawing&quot;);</span><br><span class="line">decl M6 = db_get_layerid(context, &quot;M6&quot;, &quot;drawing&quot;);</span><br><span class="line">decl M5 = db_get_layerid(context, &quot;M5&quot;, &quot;drawing&quot;);</span><br><span class="line">decl M4 = db_get_layerid(context, &quot;M4&quot;, &quot;drawing&quot;);</span><br><span class="line">decl M3 = db_get_layerid(context, &quot;M3&quot;, &quot;drawing&quot;);</span><br><span class="line">decl M2 = db_get_layerid(context, &quot;M2&quot;, &quot;drawing&quot;);</span><br><span class="line">decl M1 = db_get_layerid(context, &quot;M1&quot;, &quot;drawing&quot;);</span><br><span class="line">decl Metals = list(M1, M1, M2, M3, M4, M5, M6, M7, M8, M9, AP);</span><br><span class="line">decl via9 = db_get_layerid(context, &quot;via9&quot;, &quot;drawing&quot;);</span><br><span class="line">decl via8 = db_get_layerid(context, &quot;via8&quot;, &quot;drawing&quot;);</span><br><span class="line">decl via7 = db_get_layerid(context, &quot;via7&quot;, &quot;drawing&quot;);</span><br><span class="line">decl via6 = db_get_layerid(context, &quot;via6&quot;, &quot;drawing&quot;);</span><br><span class="line">decl via5 = db_get_layerid(context, &quot;via5&quot;, &quot;drawing&quot;);</span><br><span class="line">decl via4 = db_get_layerid(context, &quot;via4&quot;, &quot;drawing&quot;);</span><br><span class="line">decl via3 = db_get_layerid(context, &quot;via3&quot;, &quot;drawing&quot;);</span><br><span class="line">decl via2 = db_get_layerid(context, &quot;via2&quot;, &quot;drawing&quot;);</span><br><span class="line">decl via1 = db_get_layerid(context, &quot;via1&quot;, &quot;drawing&quot;);</span><br><span class="line">decl Vias = list(via1, via1, via2, M3, M4, M5, M6, M7, M8, M9, AP);</span><br><span class="line"></span><br><span class="line">decl layerM1 = Metals[MT];</span><br><span class="line">decl layerM2 = Metals[MB];</span><br><span class="line"></span><br><span class="line">decl i = 0;</span><br><span class="line">decl Dw = grid_ceil2( D / 2 );</span><br><span class="line">decl Dh = grid_ceil2( D / 2 * RH );</span><br><span class="line">decl Dd = grid_ceil2( D * RD / sqrt(2) );</span><br><span class="line">decl ew = grid_ceil2( W * (sqrt(2) - 1) );</span><br><span class="line">decl es = grid_ceil2( S * (sqrt(2) - 1) );</span><br><span class="line"></span><br><span class="line">decl iDW = Dw;</span><br><span class="line">for(i = 0; i &lt; C - 1; i++)</span><br><span class="line">iDW = grid_floor2( iDW - ew - es );</span><br><span class="line">decl wv = grid_floor(iDW - (1 + (W + S + ew) / 2));</span><br><span class="line">if(wv &gt; 2 * W)</span><br><span class="line">wv = 2 * W;</span><br><span class="line">decl t = grid_floor( wv + 1 + (W + S + ew) / 2 );</span><br><span class="line"></span><br><span class="line">create_tj(context, layerM1, W, s1, t, w2, s2, e, x, y+Dh+Dd-W, dir);</span><br><span class="line"></span><br><span class="line">for(i = 0; i &lt; C; i++)</span><br><span class="line">&#123;</span><br><span class="line">create_coil(context, layerM1, Dw, Dh, Dd, W, t, x, y);</span><br><span class="line">decl newDw = grid_floor2( Dw - ew - es );</span><br><span class="line">decl newDh = grid_floor2( Dh - ew - es );</span><br><span class="line">decl newDd = grid_floor2( Dd - W - S + ew + es );</span><br><span class="line">if(newDd &lt; 0)</span><br><span class="line">&#123;</span><br><span class="line">newDw = newDw + newDd;</span><br><span class="line">newDh = newDh + newDd;</span><br><span class="line">newDd = 0;</span><br><span class="line">&#125;</span><br><span class="line">decl cs = Dh + Dd - newDh - newDd - W;</span><br><span class="line">if(i != C - 1)</span><br><span class="line">&#123;</span><br><span class="line">if(dir == 0)</span><br><span class="line">&#123;</span><br><span class="line">create_crossing(context, layerM1, W, cs, t, x, y-Dh-Dd, 1, 1);</span><br><span class="line">create_crossing(context, layerM2, W, cs, t, x, y-Dh-Dd, -1, 1);</span><br><span class="line">via_fill7to9(MB, MT, wv, W, 0.3, 0.3, 0.3, 0.3, x-t, y-(Dh+Dd)+W+cs, combine);</span><br><span class="line">via_fill7to9(MB, MT, wv, W, 0.3, 0.3, 0.3, 0.3, x+t-wv, y-(Dh+Dd), combine);</span><br><span class="line">&#125;</span><br><span class="line">if(dir == 1)</span><br><span class="line">&#123;</span><br><span class="line">create_crossing(context, layerM1, W, cs, t, x, y+Dh+Dd, 1, -1);</span><br><span class="line">create_crossing(context, layerM2, W, cs, t, x, y+Dh+Dd, -1, -1);</span><br><span class="line">via_fill7to9(MB, MT, wv, W, 0.3, 0.3, 0.3, 0.3, x-t, y+Dh+Dd-2*W-cs, combine);</span><br><span class="line">via_fill7to9(MB, MT, wv, W, 0.3, 0.3, 0.3, 0.3, x+t-wv, y+Dh+Dd-W, combine);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">db_add_rectangle(context, layerM1, x-t, y+pow(-1, dir+1)*(Dh+Dd), x+t, y+pow(-1, dir+1)*(Dh+Dd-W));</span><br><span class="line">Dw = newDw;</span><br><span class="line">Dh = newDh;</span><br><span class="line">Dd = newDd;</span><br><span class="line">dir = 1 - dir;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defun create_diff_inductor2(context, MT, MB, D, W, S, C, RH, RD, s1, w2, s2, e, x, y, dir, combine)</span><br><span class="line">&#123;</span><br><span class="line">D = grid_ceil2( D * RH );</span><br><span class="line">RH = 1 / RH;</span><br><span class="line">RD = RD * RH;</span><br><span class="line">create_diff_inductor(context, MT, MB, D, W, S, C, RH, RD, s1, w2, s2, e, x, y, dir, combine);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defun diff_inductor(MT, MB, D, W, S, C, RH, RD, s1, w2, s2, e, dir, combine)</span><br><span class="line">&#123;</span><br><span class="line">decl designContext = de_get_current_design_context();</span><br><span class="line">decl mks2uu = db_get_mks_to_uu_factor(designContext);</span><br><span class="line"></span><br><span class="line">D = D * mks2uu;</span><br><span class="line">W = W * mks2uu;</span><br><span class="line">S = S * mks2uu;</span><br><span class="line">C = floor(C);</span><br><span class="line">s1 = s1 * mks2uu;</span><br><span class="line">w2 = w2 * mks2uu;</span><br><span class="line">s2 = s2 * mks2uu;</span><br><span class="line">e = e * mks2uu;</span><br><span class="line">dir = floor(dir);</span><br><span class="line">combine = floor(combine);</span><br><span class="line"></span><br><span class="line">create_diff_inductor2(designContext, MT, MB, D, W, S, C, RH, RD, s1, w2, s2, e, 0, 0, dir, combine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> RFIC </tag>
            
            <tag> Inductor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二阶系统</title>
      <link href="/archives/5777cf8/frequency-response.html"/>
      <url>/archives/5777cf8/frequency-response.html</url>
      
        <content type="html"><![CDATA[<p>本文介绍了二阶系统的基本概念。</p><a id="more"></a><h2 id="二阶系统"><a href="#二阶系统" class="headerlink" title="二阶系统"></a>二阶系统</h2><p>二阶系统的传递函数为</p><script type="math/tex; mode=display">G(s)=\frac{\omega_n^2}{s^2+2\zeta\omega_ns+\omega_n^2}</script><p>其中$\omega_n$为自然频率，也可写成</p><script type="math/tex; mode=display">G(j\omega)=\frac{1}{1-(\frac{\omega}{\omega_n})^2+j2\zeta\frac{\omega}{\omega_n}}</script><h3 id="瞬态分析"><a href="#瞬态分析" class="headerlink" title="瞬态分析"></a>瞬态分析</h3><p>极点为</p><script type="math/tex; mode=display">-\zeta\omega_n\pm\omega_n\sqrt{\zeta^2-1}</script><p>其实部定义为阻尼（damping）</p><script type="math/tex; mode=display">\sigma=-\zeta\omega_n</script><p>虚部定义为衰减后振荡频率（damped natural frequency）</p><script type="math/tex; mode=display">\omega_d=\omega_n\sqrt{1-\zeta^2}</script><p>因此</p><ul><li>$\zeta&lt;-1$，极点为右半平面一对不相等实数（无震荡发散）</li><li>$\zeta=-1$，极点为右半平面一对相等实数（发散，无震荡临界情况）</li><li>$-1&lt;\zeta&lt;0$，极点为右半平面一对复数（震荡发散）</li><li>$\zeta=0$，极点为虚轴上一对大小相等符号相反的虚数（无衰减震荡）</li><li>$0&lt;\zeta&lt;1$，极点为左半平面一对复数（欠阻尼衰减）</li><li>$\zeta=1$，极点为左半平面一对相等实数（衰减，临界阻尼）</li><li>$\zeta&gt;1$，极点为左半平面一对不相等实数（过阻尼衰减）</li></ul><p>当有输入信号为阶跃函数时，有</p><script type="math/tex; mode=display">\begin{aligned}Y(s) &=G(s) \cdot U(s) \\&=\frac{\omega_{n}^{2}}{s^{2}+2 \zeta \omega_{n} s+\omega_{n}^{2}} \cdot \frac{1}{s} \\&=\frac{\omega_{n}^{2}}{(s+\sigma)^{2}+\omega_{d}^{2}} \cdot \frac{1}{s} \\&=\frac{1}{s}-\frac{s+\sigma}{(s+\sigma)^{2}+\omega_{d}^{2}}-\frac{\sigma}{\omega_{d}} \frac{\omega_{d}}{(s+\sigma)^{2}+\omega_{d}^{2}}\end{aligned}</script><p>相应的时域表达式为</p><script type="math/tex; mode=display">\begin{aligned}y(t) &=1-e^{-\sigma t} \cos \omega_{d} t-\frac{\sigma}{\omega_{d}} e^{-\sigma t} \sin \omega_{d} t \\&=1-e^{-\sigma t}\left(\cos \omega_{d} t+\frac{\sigma}{\omega_{d}} \sin \omega_{d} t\right), t \geq 0\end{aligned}</script><h3 id="稳态分析"><a href="#稳态分析" class="headerlink" title="稳态分析"></a>稳态分析</h3><p>幅频响应为</p><script type="math/tex; mode=display">A(\omega)=|G(j \omega)|=\frac{1}{\sqrt{\left[1-\left(\frac{\omega}{\omega_{n}}\right)^{2}\right]^{2}+\left(2 \zeta \frac{\omega}{\omega_{n}}\right)^{2}}}</script><p>相频响应为</p><script type="math/tex; mode=display">\varphi(\omega)=-180^{\circ}+\arctan \frac{\left(\frac{\omega}{\omega_{n}}\right)^{2}-1}{2 \zeta \frac{\omega}{\omega_{n}}}</script><p>分析三种边界情况，有</p><script type="math/tex; mode=display">\begin{aligned}\omega=0 &\quad  A(0)=1, \varphi(0)=0^{\circ} \\\omega=\omega_{n} &\quad A(\omega)=\frac{1}{2 \zeta},\varphi\left(\omega_{n}\right)=-90^{\circ} \\\omega \rightarrow \infty &\quad A(\infty)=0, \varphi(\infty)=-180^{\circ}\end{aligned}</script><p>对幅频响应的分母求极值，得到谐振频率</p><script type="math/tex; mode=display">\omega_r=\omega_n\sqrt{1-2\zeta^2}</script><p>以及谐振时的幅值和相位</p><script type="math/tex; mode=display">A(\omega_r)=\frac{1}{2\zeta\sqrt{1-\zeta^2}}</script><script type="math/tex; mode=display">\varphi(\omega_r)=-\arctan\frac{\zeta}{\sqrt{1-2\zeta^2}}</script><p>因此，阻尼因子$\zeta $决定了</p><ul><li>当$\zeta&gt;1/\sqrt{2}$时，不存在谐振频率</li><li>当$\zeta=1/\sqrt{2}$时，$\omega_r=0, A(\omega_r)=1, \varphi(\omega_r)=0$</li><li>当$0&lt;\zeta&lt;1/\sqrt{2}$时，存在谐振频率</li><li>当$\zeta=0$时，$\omega_r=\omega_n, A(\omega_r)\rightarrow\infty, \varphi(\omega_r)=-90^{\circ}$</li></ul><p>画出幅频响应和相频响应曲线则有</p><p><img src="frequency-response\zeta-and-resonance" alt="zeta-and-resonance"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/48169298" target="_blank" rel="noopener">控制理论学习笔记（4）——一阶系统和二阶系统</a>.</li><li>孙晓波, 李双全, 王海英. 自动控制原理. 科学出版社, 2006.</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Circuit Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>To the Unlimited</title>
      <link href="/archives/a9a43bb7/to-the-unlimited.html"/>
      <url>/archives/a9a43bb7/to-the-unlimited.html</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="Oh, these decrypted content cannot be verified, but you can still have a look."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="Hey, password is required here." /><label>Hey, password is required here.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="dd45b1824747f4c93808b282b9d6446778e997cad232f37bfe5711a19331c128">c05a2a2b7483cfedc240ddab7251d90348238402f8ffcb75fbefcb3cdcd632858c247a68c2f1f3d2d6e84e49418bed0f66356befa71dee0c7641b07481dce02713827653520d83f38d01643ca1e9e240df627479bd7fb64012ed59ce46b51259dd3a1b8a7156d0395350946696bc386feacccb9b68446a6dfeca57d6c92f7882ba0b697fd3db26a67cba30af2ad8a108fa8852497c2abb1e1c75c2d06d5d1774953a771c26d2fcf3f953d27bef3484758d77dd4806c0c6177231ac459993b59fba7c4d7d40d94bc3dfea52796dbc592a77b50ccd404c5ddb2488f1f073f2fbdcb9830e4087df117c537d1db151dfb0dc3f41d475485baa3a338445b0212fd0d1a3f2b87875bb7774fdcece111fc68967bcb667663a1e6d9a348dd89206044bc5fd8ed3f9e7b328d8fbe6fb945b766d6fe30099011b8c46ef3d40edd3bb415b00a58aec6ff12060ef2bb76744e2c34a89d4d6f97d1f4938b5b83081f06bca7247bc1e688b10b52da519532dd34f7e0b37bf0d06ea62987d91161bc4d27ee4fda7eb83d0a465c9cea05877490a6d7ae3a600f929e329918a10e5c5d9260be656babce62eb9feea815656377c287665f8f212a5aa23794b6a74a9be5fa11ae0699acf9905bb211fec1226335b9457acd9a32a819aa4b5cac62562fc2d092a9433545f6b22403b8cd2e76188fcdfc975c4b26d7613c1b84e6bcf2a42adb4e2ef4477ad2f846c40e96693876a9fbbd73d7962572f8f64ba3fe72e6966ef638f68e731bf04eff2af38f4b43b1954528f90cb5505e1759c36b32dbb5f9834664bb1a2072dc58638302d25d3ece361a57c7d29338629fed738bfac3151b673326e75fe72a333cc19c0c2f631b52f590705d1e1c26eb6cad39adb448375d151a4d020e40d9f8f0467852db54bb907eae39a4f82e308e594d3efece036ef7874cf7c43ba89fea4033c2c7dc4f85fcc79f91bf329aae62cbec31160c16c6b02d1af8347ddeb334be7f2b823337dc4912076474250906a0bc21dd2c6e9719135a6466a887ea17350b1f7044cfed9240b975d24e5ea97a8a3a997510720b1f8967be1166051d022e9dce8f3706bbb7cce429290857be5f253316674ebf0fe2e01d4b90ac63fe4b837631a169da532d467623545e6a815d6814fcaf09979a1d2a3b6ce6d5f3657c08286d30918b30d3b2fb022807162c116ca67421db026e971ff59ebeb65d01518d0ea54d1a36b8549c5bb10974da811009a1b68bf1ed12433609b0a946e5700152a4c4e71a2a453ca654b8681e75c3777e720e383cf17d08674a003beb571207a958825bdf0ec4a4f2c2af5383e853aa00e9e046e7f4b2f0aafe749d8896b9e6f58547651f3ab2ea725646a81e3fa9ad30b5745eb46d5265a3a2474ace1654dae4ec1e20c90c27775c74e6e3536dba950d124079aec82f6c106bb2082822216321de7612ea5b26201e666154a5d4c4d6bfea01c7289f66563375f1229f40a18b29efedb2d3709568fc6c15b8b0a25bf55d9f36e8c983af5b387a09ce77bddaf69e0545a285bf44d992a3f2260cb25ee43b1fe372261aff958aaff1a25b062bb19bb65e8c4f23a95394c4125e86e763a187dfb145de06a270a4a3f0c6a4365b4ef8b17b0377b100315be0898ee8c86c1316eb5122a1a528e1627eb7fabb3d406a6ff2f318d329002168f1e6330d9bd322d7382c891cdc29cfadf9c4f8777285254e0f9816ea76546801661a8e5675f7272acefed5f782ee24af617c4cdee074b54b79c961e722e515ed7f12cfb57fe5e868457cb1d56a481a0798ef8f939c142b01de7b50ace298b7ce185a56536a55162966a135023498dc548f71ef8d420ad6c38e93d8c8d54bff23cb99b37a9ef2fee6ed24a2263af3a8f3fd74591721711a507a24027844b0f335eccdbcabcf4a1201e7fc38bfecf2e974132524d90ea477625c0d574c95598058ffd164ae72ef2b4b341043c448a487482b5e8d60f234faa2dad43993fc1b1904d12a0eaa3a605dd93f5d6e7e477ffcc8c18aeddfc6c36d0a5ff3c0b332849f0fc19a11d93029272013debb3d45ae7139aae00a7b5bdc40d4ce8828c01e23e0aa32a4f79d55ab1a507a9ab56d72625b037dea53000e9fe0b2b202088827e87bd7014eacfc28059eb8af6e602f2eac42df5ec6d80387eb3024a689eb41104297974a8e3a7b5c9c4e3e7b8e60647294d8ecbdc7a098ba1ec61615b0935b48dc538354143155adb6cc77b0869d86c331a58dc0916d291ab40cfa661692a47c42d31d79a03d04e5de5662fc6b784357da778f8dea6da50dc84ce51881c046cd18d96389d39bad890422e5674637a1002f3ac2e8a567ca07bae12fa28dee4f850a71233cad8e408781acb987acd3698ffb88ca4ff19a3d35d5aac61584be282c3718dabc8778f106e2ead22f2bc48a3c5b52d8bfe544bdaebd2eefe8e68c225d930332d5d1b73a1b60562d26e035d9232330fa7de04e0f009dc0b4b57a60fd05596f87b735d31ae94db747ed0f47bc5127af953b8158628174567a3c06cdea36351cb740aa2f4dd15ffafe4f242e70d4c73a680c1d9d5eeaa38ff1a2f41e4a19ddf9f930ae0fbf80e661a1f14f22924af37da442337f25d8db2aade2a1164d8d4ccebcfce5f956e147b72b658d5b1db59a6cc66217217d256676ae276b07363e15ba1d294fa0d195b8487cf979d45df9b95ab2568abce266d47ac9557144941feb90e0f8ca1128bbc2b400524eac72f2645d239d9cafd76bc08ecf243918933722c105cee8224572f62111bc15c28e78fc99b33116001b1ea7455c834ba1942581c50eadde3867469ab756badb1136fb581a926917df3e613c9a1f718a1ed8be72a5c25db00f52bee1a472bc838f0b1ed512adc502c08836225839d7d1991852c1e7cd716d22d2fb9197b6971cef3883a249708c7c4c460f95534fad524b3e4b56f4c05c9f20ab03579ff2d8daf5bdbe6848e5c6b8282e811352af51f218b2cb9baf7f9a3ec18d641c91463c1d4d67fcf7262d1c12ce3f1a43777b1a047cfdf62394ba79746e53c986b72cb0229e35f2e586278db6a2578e5ee3d9b90e9ddc729db182ef945f3c607be949d52782bade44117fbe5e300fc537c50709d602e5843b943f0ee676ca7b556f0f8f9a442ac5df9b34902e6350e4c99acbbb9228a09b72232bd249f5f2e79c421cff9d92e4ce1c37b7c76eea576b426a9fb9fd4732b3818b136b64794f84da8a3365d1d081b210c5b6c8298375fe01efa726ba6d9244f93edb5a04be2e8789510f7d64243b6f10d28a557898f4e8dad1423c017ddd75c3ab6eec4dcb292dad5d77aae7fbf61b6938d64280cec758d4218c40d4dd686a6713da968bc103240c4da0011dd1dee552629b33af15c8870bedf35e3ab466ebf7c87f49a2dc9eb848e476c267314a4b44005d39aeb9492387ea6d83f51760861cbbc3761da303eb1b972244aded006c29a600c6909c50e11b1e9ae05270367eec4a8481a286b74d7cc98a4744c2b42dbd1b02fafdff39f10b5a667f76a57af787aa7fbecab4a0a700d162869bf51eece147908263831bfd406222b41e29cd3f51902afffa38d7fe50624d221dceae8fd89dd5cd9bcc31c25bfb6cc32eed0479237373694c7d4cdd3b8ae1ce321c0f1d0f973ac360bd0a204c6f0c81227e0ee45c578ec704bdf414c2f13ecca91831d5b374a6423283a6bd6101f9f893aff0d9efa377a61cf28f57ecea8166d4efd6afed68fbfee8f56009fff3e276bf84c505150f53d104913bac22efc72dc4931ecc8ce0503d342505cd6a2212574f367a8034e85c89a74fbef42f72e89032b47eabfb247fe3fca33e985c75d0a4265d54e8199f7fcfed31e77619dafe0369a7c32710fa635c474705c9cc253c73a6bbb2f0efd2744e574eb7c56e61b2489f2bf1c34356bc1a42214094f555e660eda67b2900b99642cc311b46060d5b1a347e1780a965b004d0577494f49d0f08298d47133fca148f3e60ea37822b89df0b70e7e6a40cdec33043e90c193fa51b855d07649dc914a4f0833451a11b2aa74f17d00549a86abeb1476d6d6fa83c0c6dcf65e24484226bd5ab56786109f097365227d11b35b25814055a891b86508772996b1a9685fbabb0753ce7357dd54e5e477782d5e4fbc424b129f58a1b53adeae6eae2bd4fee8e4baba66267c8abb7e21328fe92ff09dfb96e2f0feb4491d3ea471937ce46237dbaabf866d3a02fef18d57a63014b4d98c105e7223978cde7f86d62c365cb9b3c4eea520544917bb0ee421be894540fca66f85ebc1a9ce54a8e03877eaeb06ba11385c87709436305b4f27278284661ca1eb255b0b73c2d224f0eeae9f07faba10104d02595c5f0eeaac8068f8e8b7502e6e057b2c2a1e6ae7db663d54acd7871811cdd78305bc4f35174ac913cd5d79d5badff444c02b48b276a7e874768b5c3b3aa9ab0da121a9f2dbd407a62cc0949655fe0ff38e5ca9a105df336009459289a3b55af816ea9122f38a289148ce40274e098cf27c0a903f9a5cbe219317cb875f95c1be3a84e02802bc083e630387ead25a3473ccff70891dfcbb810ae2e3fc1ef409aaadf56dd19a713eae48f8f7c01aef5d3d16f43c7a0de4b0c12836be5b70bc88f6e0130cd89832d288481225436d1e63ebaeeefe7ca49194994ba42b35a119551280d9a1348a99a4b7f216ae23d5f933f734</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> ENCv1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变压器的跨阻推导</title>
      <link href="/archives/33e60fbc/transformer-equation-derivation.html"/>
      <url>/archives/33e60fbc/transformer-equation-derivation.html</url>
      
        <content type="html"><![CDATA[<p>变压器是射频集成电路设计中极为重要的元件，它可以提供：</p><ul><li>初级线圈和次级线圈的直流阻断</li><li>初级线圈的次级线圈的中心抽头是虚地，可用于连接直流偏置</li><li>阻抗匹配</li></ul><p>在毫米波频段，其占用面积小，可实现的插入损耗、带宽相比于分立元件有较大优势。变压器的分析通常使用电感耦合的RLC谐振网络进行。</p><a id="more"></a><p><img src="transformer-equation-derivation/mcr.svg" alt="mcr"></p><p>本文复现了两篇论文对变压器$Z_{21}$的分析、推导。</p><h2 id="Haikun-Jia的推导"><a href="#Haikun-Jia的推导" class="headerlink" title="Haikun Jia的推导"></a>Haikun Jia的推导</h2><p>Jia推导的核心在于直接列写KCL、KVL方程。</p><script type="math/tex; mode=display">\left\{\begin{aligned}j\omega L_1I_{p1}+j\omega MI_{p2}=U_1\\j\omega MI_{p1}+j\omega L_2I_{p2}=U_2\\I_1-j\omega C_1U_1-\frac{U_1}{R_1}=I_{p1}\\-j\omega C_2U_2-\frac{U_2}{R_2}=I_{p2}\\\end{aligned}\right.</script><p>之后直接求解</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br><span class="line">syms R1 L1 C1 R2 L2 C2 M s</span><br><span class="line">syms V1 V2 Ip1 Ip2 Iin</span><br><span class="line"></span><br><span class="line"><span class="comment">%Transformer equations</span></span><br><span class="line"><span class="comment">%V2 == 1i * w * L2 * Ip2 + 1i * w * M * Ip1</span></span><br><span class="line"><span class="comment">%V1 == 1i * w * L1 * Ip1 + 1i * w * M * Ip2</span></span><br><span class="line"><span class="comment">%1i * w * C2 * V2 + V2 / R2 == -Ip2</span></span><br><span class="line"><span class="comment">%Ip1 + 1i * w * C1 * V1 + V1 / R1 == Iin</span></span><br><span class="line"></span><br><span class="line">syms A b x</span><br><span class="line"><span class="comment">% x = [V1; V2; Ip1; Ip2]</span></span><br><span class="line"><span class="comment">% Ax == b</span></span><br><span class="line"></span><br><span class="line">A = [<span class="number">0</span>, <span class="number">1</span>, -s * M, -s * L2;</span><br><span class="line">    <span class="number">1</span>, <span class="number">0</span>, -s * L1, -s * M;</span><br><span class="line">    <span class="number">0</span>, (s * C2 + <span class="number">1</span> / R2), <span class="number">0</span>, <span class="number">1</span>;</span><br><span class="line">    (s * C1 + <span class="number">1</span> / R1), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];</span><br><span class="line">b = [<span class="number">0</span>; <span class="number">0</span>; <span class="number">0</span>; Iin];</span><br><span class="line">x = A\b;</span><br><span class="line">x = x(<span class="number">2</span>) / Iin</span><br></pre></td></tr></table></figure><p>结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = </span><br><span class="line"></span><br><span class="line">(M*R1*R2*s)/(R1*R2 - M^2*s^2 + L1*R2*s + L2*R1*s + L1*L2*s^2 - C1*M^2*R1*s^3 - C2*M^2*R2*s^3 + C1*L1*L2*R1*s^3 + C2*L1*L2*R2*s^3 + C1*L1*R1*R2*s^2 + C2*L2*R1*R2*s^2 - C1*C2*M^2*R1*R2*s^4 + C1*C2*L1*L2*R1*R2*s^4)</span><br></pre></td></tr></table></figure><p>手动整理后可得</p><script type="math/tex; mode=display">Z_{21}=\frac{sR_1R_2M}{(L_1L_2-M^2)C_1C_2R_1R_2s^4+(C_1R_1-C_2R_2)(L_1L_2-M^2)s^3+\\ [(C_1L_1 + C_2L_2)R_1R_2+(L_1L_2- M^2)]s^2+(L_1R_2 + L_2R_1)s + \\ R_1R_2}</script><p>可以利用公式将$M, L, C, R$转换为$k, \omega, R, Q$，相应的公式为：</p><script type="math/tex; mode=display">L=\frac{R}{\omega Q}</script><script type="math/tex; mode=display">C=\frac{Q}{\omega R}</script><script type="math/tex; mode=display">M=k\sqrt{L_1L_2}</script><p>于是，在Matlab中输入命令</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syms Q1 Q2 w1 w2 k</span><br><span class="line"><span class="comment">% convert RLC parameters to RQw parameters</span></span><br><span class="line">x = subs(x, M, <span class="built_in">sqrt</span>(L1 * L2) * k);</span><br><span class="line">x = subs(x, L1, R1 / w1 / Q1);</span><br><span class="line">x = subs(x, L2, R2 / w2 / Q2);</span><br><span class="line">x = subs(x, C1, Q1 / w1 / R1);</span><br><span class="line">x = subs(x, C2, Q2 / w2 / R2)</span><br></pre></td></tr></table></figure><p>可以得到推导结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = </span><br><span class="line"></span><br><span class="line">(R1*R2*k*s*((R1*R2)/(Q1*Q2*w1*w2))^(1/2))/(R1*R2 + (R1*R2*s^2)/w1^2 + (R1*R2*s^2)/w2^2 + (R1*R2*s^4)/(w1^2*w2^2) + (R1*R2*s)/(Q1*w1) + (R1*R2*s)/(Q2*w2) + (R1*R2*s^3)/(Q1*w1*w2^2) + (R1*R2*s^3)/(Q2*w1^2*w2) - (R1*R2*k^2*s^4)/(w1^2*w2^2) + (R1*R2*s^2)/(Q1*Q2*w1*w2) - (R1*R2*k^2*s^3)/(Q1*w1*w2^2) - (R1*R2*k^2*s^3)/(Q2*w1^2*w2) - (R1*R2*k^2*s^2)/(Q1*Q2*w1*w2))</span><br></pre></td></tr></table></figure><p>手动整理，将$R_1R_2$移到分母，将移到$\omega_1^2\omega_2^2$分子，可得</p><script type="math/tex; mode=display">Z_{21}=\frac{k\omega_1^2\omega_2^2\sqrt{\frac{R_1R_2}{Q_1Q_2\omega_1\omega_2}}s}{Q_1Q_2(1-k^2)s^4+(Q_1\omega_2+Q_2\omega_1)(1-k^2)s^3+\\ [\omega_1\omega_2(1-k^2)+Q_1Q_2(\omega_1^2+\omega_2^2)]s^2+\omega_1\omega_2(Q_1\omega_1+Q_2\omega_2)s+\\Q_1Q_2\omega_1^2\omega_2^2}</script><p>得到了文章中的公式。此外，可以进一步简化，使初级、次级的$\omega, Q, R$对应相等，利用</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syms Q w R</span><br><span class="line">x = subs(x, Q1, Q);</span><br><span class="line">x = subs(x, Q2, Q);</span><br><span class="line">x = subs(x, w1, w);</span><br><span class="line">x = subs(x, w2, w);</span><br><span class="line">x = subs(x, R1, R);</span><br><span class="line">x = subs(x, R2, R);</span><br><span class="line">x = simplify(x)</span><br></pre></td></tr></table></figure><p>得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x =</span><br><span class="line"> </span><br><span class="line">(Q^2*k*s*w^4*(R^2/(Q^2*w^2))^(1/2))/(- Q^2*k^2*s^4 + Q^2*s^4 + 2*Q^2*s^2*w^2 + Q^2*w^4 - 2*Q*k^2*s^3*w + 2*Q*s^3*w + 2*Q*s*w^3 - k^2*s^2*w^2 + s^2*w^2)</span><br></pre></td></tr></table></figure><p>即</p><script type="math/tex; mode=display">Z_{21}=\frac{\omega^3kQRs}{(1-k^2)Q^2s^2+2(1-k)Q\omega s+(1-k^2+2Q^2)\omega^2s^2+2Q\omega^3s+Q^2\omega^4}</script><h2 id="Marco-Vigilante的推导"><a href="#Marco-Vigilante的推导" class="headerlink" title="Marco Vigilante的推导"></a>Marco Vigilante的推导</h2><p>Marco巧妙地利用了Y参数，避免了很多的复杂计算。变压器方程为</p><script type="math/tex; mode=display">\left\{\begin{aligned}U_1=j\omega L_1I_1+j\omega MI_2\\U_2=j\omega MI_1+j\omega L_2I_2\\\end{aligned}\right.</script><p>变换后为</p><script type="math/tex; mode=display">\left\{\begin{aligned}I_1=\frac{L_2}{j\omega(L_1L_2-M^2)}U_1+\frac{-M}{j\omega(L_1L_2-M^2)}U_2\\I_2=\frac{-M}{j\omega(L_1L_2-M^2)}U_1+\frac{L_1}{j\omega(L_1L_2-M^2)}U_2\\\end{aligned}\right.</script><p>因此得到了Y参数。取$s=j\omega, L=L_1=L_2, M=kL$，有</p><script type="math/tex; mode=display">\left\{\begin{aligned}I_1=\frac{1}{sL(1-k^2)}U_1+\frac{k}{sL(1-k^2)}U_2\\I_2=\frac{k}{sL(1-k^2)}U_1+\frac{1}{sL(1-k^2)}U_2\\\end{aligned}\right.</script><p>此时，加上两侧的电容，电阻，并令</p><script type="math/tex; mode=display">\omega=\frac{1}{\sqrt{LC(1-k^2)}}</script><script type="math/tex; mode=display">Q=\frac{R}{\omega L(1-k^2)}=\omega RC</script><p>可以得到整体Y参数为</p><script type="math/tex; mode=display">\left\{\begin{aligned}I_1=\frac{1}{R}\left[1+Q\left(\frac{s}{\omega}+\frac{\omega}{s}\right)\right]U_1-\frac{\omega kQ}{sR}U_2\\I_2=-\frac{\omega kQ}{sR}U_1+\frac{1}{R}\left[1+Q\left(\frac{s}{\omega}+\frac{\omega}{s}\right)\right]U_2\\\end{aligned}\right.</script><p>此时，对Y参数矩阵求逆</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br><span class="line">syms R Q w s k</span><br><span class="line">syms Y</span><br><span class="line">Y = [<span class="number">1</span> / R * (<span class="number">1</span> + Q * (s / w + w / s)), -k * w * Q / s / R;</span><br><span class="line">    -k * w * Q / s / R, <span class="number">1</span> / R * (<span class="number">1</span> + Q * (s / w + w / s))];</span><br><span class="line">x = <span class="built_in">eye</span>(<span class="number">2</span>)/Y;</span><br><span class="line">x(<span class="number">2</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>得到结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ans =</span><br><span class="line"></span><br><span class="line">(Q*R*k*s*w^3)/(- Q^2*k^2*w^4 + Q^2*s^4 + 2*Q^2*s^2*w^2 + Q^2*w^4 + 2*Q*s^3*w + 2*Q*s*w^3 + s^2*w^2)</span><br></pre></td></tr></table></figure><p>手动整理可得</p><script type="math/tex; mode=display">Z_{21}=\frac{\omega^3kQRs}{(Qs^2+\omega s+Q(1+k)\omega^2)(Qs^2+\omega s+Q(1-k)\omega^2)}</script><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用两种方法都能够推导出变压器$Z_{21}$的表达式，仔细观察两者简化后的表达式分母虽然一致，分子却有所区别，这是因为两者定义$Q, \omega$的方式不尽相同。尽管如此，这两种方法都可以进一步推导出两个极点的位置，用于指导变压器的宽带设计。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>H. Jia, C. C. Prawoto, B. Chi, Z. Wang and C. P. Yue, “A Full Ka-Band Power Amplifier With 32.9% PAE and 15.3-dBm Power in 65-nm CMOS,” in <em>IEEE Transactions on Circuits and Systems I: Regular Papers</em>, vol. 65, no. 9, pp. 2657-2668, Sept. 2018. DOI: <a href="https://doi.org/10.1109/TCSI.2018.2799983" target="_blank" rel="noopener">10.1109/TCSI.2018.2799983</a></li><li>M. Vigilante, P. Reynaert, 5G and E-Band Communication Circuits in Deep-Scaled CMOS. Switzerland: Springer, 2018. DOI: <a href="https://doi.org/10.1007/978-3-319-72646-5" target="_blank" rel="noopener">10.1007/978-3-319-72646-5</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> RFIC </tag>
            
            <tag> Transformer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电容的电磁场仿真设置</title>
      <link href="/archives/10ba08e5/mom-simulation.html"/>
      <url>/archives/10ba08e5/mom-simulation.html</url>
      
        <content type="html"><![CDATA[<p>电容是射频集成电路中的常用器件，其结构固定，设计较为简单。但由于精细结构较多，往往占用极大的仿真资源和时间。在隔直或者交流去耦应用中，电容的精确值并不是那么重要，只要足够大即可。即使在匹配电路中，些许偏差也不会对中心频率产生明显影响。因此，电容仿真不应无止尽追求精度，而是要在尽可能短的时间内获得误差不大的仿真结果。本文对比了电容仿真中不同的仿真引擎和通孔合并方法的优劣，并给出了推荐设置。<br><a id="more"></a></p><h2 id="仿真引擎的选择"><a href="#仿真引擎的选择" class="headerlink" title="仿真引擎的选择"></a>仿真引擎的选择</h2><p>常用的ADS Momentum引擎有两种模式：RF和Microwave。RF模式在射频频段内提供了精确的电磁场仿真结果，且仿真速度较快。在更高频段内，由于辐射效应，只用Microwave才能提供准角结果。ADS文档中推荐在以下电路中使用RF模式：</p><ul><li>电小的</li><li>图形复杂的</li><li>不辐射的</li></ul><p>在射频频段的电容应用应当符合RF的描述，之后通过仿真对比予以验证。另一个值得注意的的Edge Mesh的设置。Edge mesh将自动的在图形边缘添加密布的mesh，用于仿真趋肤效应，常用于高层金属的仿真。之后也通过仿真比较了Edge Mesh在电容仿真中的影响。</p><p>对比实验选则了MOM电容，由5层金属，36根19.74 um长插指构成，两侧通孔采用减少面积合并。仿真在32核服务器上顺序进行，无其他负载。结果如下：</p><p><img src="./mom-simulation/simulation-engine.png" alt="simulation-engine"></p><p>在14 GHz计算得到的仿真误差如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">电容误差</th><th style="text-align:center">Q值误差</th><th style="text-align:center">仿真时间</th></tr></thead><tbody><tr><td style="text-align:center">Microwave，Edge Mesh（基准）</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">90 min</td></tr><tr><td style="text-align:center">RF</td><td style="text-align:center">1.66 %</td><td style="text-align:center">104.43 %</td><td style="text-align:center">1.5 min</td></tr><tr><td style="text-align:center">Microwave</td><td style="text-align:center">1.70 %</td><td style="text-align:center">105.72 %</td><td style="text-align:center">7.5 min</td></tr><tr><td style="text-align:center"><strong>RF，Edge Mesh</strong></td><td style="text-align:center"><strong>0.04 %</strong></td><td style="text-align:center"><strong>0.56 %</strong></td><td style="text-align:center"><strong>12 min</strong></td></tr></tbody></table></div><p>由此可见，Microwave和RF方法在14 GHz处的仿真结果相差不大，但Edge Mesh对Q值影响较大。由于趋肤效应，电流倾向于在导体边缘流动，减小了有效横截面积，因而损耗变大。当不添加Edge Mesh则无法仿真趋肤效应，直接导致偏高的Q值。因此，采用RF模式并选择Edge Mesh是平衡精度和仿真时间的最优结果。</p><h2 id="通孔的合并和模型选择"><a href="#通孔的合并和模型选择" class="headerlink" title="通孔的合并和模型选择"></a>通孔的合并和模型选择</h2><p>仿真电容时通孔阵列如果不加处理将会产生大量的网格，从而占用仿真资源并拖慢仿真速度。通常，需要将这些通孔进行合并，形成一个大的通孔。合并的方法通常有：</p><ul><li>画一个大的通孔覆盖原来所有的通孔</li><li>画一个有效面积相同的通孔</li><li>画一个大的通孔覆盖原来所有的通孔，并减小通孔导电率</li></ul><p>其中第一种方法最为简单，但不可避免增大通孔面积，低估通孔损耗。第二种方法使得通孔面积不变，但使得通孔更加集中，改变了场的分布。第三种方法需要修改衬底文件，较为麻烦，但精度较好。</p><p>另一个值得注意的时通孔模型的选择，默认选择时3D模型。此时，所有的表面电流流向都被考虑。而2D模型只考虑垂直方向的表面电流。在通孔阵列中，由于水平方向各个通孔互相独立，因此不应该有水平方向电流。而通孔合并后，物理隔离消失，因此应当选择2D模型抑制水平方向的电流，提高仿真精度。</p><p>关于修改通孔电导率，通孔电导率的计算公式为：</p><script type="math/tex; mode=display">\rho=\frac{h}{Rw^2}</script><p>其中$h$是通孔高度，$w$是通孔边长，$R$是单个通孔的电阻，这些参数都可以从代工厂提供的连线模型中找到。考虑到通孔合并，其等效电导率为：</p><script type="math/tex; mode=display">\rho_{eff}=\rho\frac{w^2}{(w+s_r)(w+s_c)}</script><p>其中是$s_r$通孔阵列的行间隔，$s_c$是列间隔。考虑$w=0.1, s_r=0.1, s_c=0.14$和$w=0.1, s_r=0.13, s_c=0.13$两种情况，其$\rho_{eff}$分别为$0.208\rho$和$0.189\rho$，因此合并时可取$\rho_{eff}=0.2\rho$。</p><p>对比实验选则了fringe电容，由5层金属，20根5 um长插指构成，采用带有Edge Mesh的RF模式仿真。仿真在32核服务器上顺序进行，无其他负载。结果如下：</p><p><img src="./mom-simulation/mom-simulation-comparison.png" alt="mom-simulation-comparison"></p><p>在14 GHz计算得到的仿真误差如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">电容误差</th><th style="text-align:center">Q值误差</th><th style="text-align:center">仿真时间</th></tr></thead><tbody><tr><td style="text-align:center">原始版图，3D（基准）</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">3 hr 5 min</td></tr><tr><td style="text-align:center"><strong>覆盖合并，2D，降低电导率</strong></td><td style="text-align:center"><strong>0.13 %</strong></td><td style="text-align:center"><strong>3.57 %</strong></td><td style="text-align:center"><strong>17 min</strong></td></tr><tr><td style="text-align:center">覆盖合并，2D</td><td style="text-align:center">0.13 %</td><td style="text-align:center">9.31 %</td><td style="text-align:center">14 min</td></tr><tr><td style="text-align:center">同面积合并，2D</td><td style="text-align:center">5.27 %</td><td style="text-align:center">53.44 %</td><td style="text-align:center">7 min</td></tr><tr><td style="text-align:center">覆盖合并，3D</td><td style="text-align:center">0.15 %</td><td style="text-align:center">10.05 %</td><td style="text-align:center">19 min</td></tr></tbody></table></div><p>仿真结果表明，同面积合并仿真速度最快，其他方法仿真速度相差无几。在合并之后，2D模型确实比3D模型更准确展现了Q值，但差距不大。前述的三种方法中， 出乎意料的是同面积合并无论是电容误差还是Q值误差都明显较大，可能是由于将通孔集中到中间与电流的趋肤效应背道而驰，人为加大了损耗。而覆盖合并方法简单有效，仅在Q值上产生一些明显误差。降低电导率后，Q值误差可以忽略不计，因此，采用2D通孔模型的覆盖合并方法最为有效。当对Q值精度要求高时，可将通孔电导率将为约1/5。</p><h2 id="通孔合并的细节"><a href="#通孔合并的细节" class="headerlink" title="通孔合并的细节"></a>通孔合并的细节</h2><p>上一部分的仿真对比结果表明了覆盖合并精度较好，但是覆盖合并的细节仍然值得注意。这里比较了两种常见覆盖合并的方法：</p><ul><li>通孔覆盖合并：画一个大的via正好覆盖原来所有的通孔</li><li>全金属填充：画一个大的via覆盖整个金属区域</li></ul><p>由于金属包围通孔的距离通常不大，两种方法的区别看似不明显。但仿真结果表现出明显的差距，三种合并方式的仿真结果如下：</p><p><img src="mom-simulation/fill-style-comparison.png" alt="fill-style-comparison"></p><p>在14 GHz计算得到的仿真误差如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">电容误差</th><th style="text-align:center">Q值误差</th></tr></thead><tbody><tr><td style="text-align:center">原始版图，3D（基准）</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center"><strong>通孔覆盖合并，3D</strong></td><td style="text-align:center"><strong>0.19 %</strong></td><td style="text-align:center"><strong>17.8 %</strong></td></tr><tr><td style="text-align:center">全金属填充，3D</td><td style="text-align:center">0.59 %</td><td style="text-align:center">144.21 %</td></tr></tbody></table></div><p>可以看出，通孔覆盖合并的电容、Q值精度都还可以接受，但全金属填空明显低估了损耗，导致较大的Q值误差。为了进一步展示三种合并方式的区别，其版图、电流密度、电流方向绘制如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">原始版图</th><th style="text-align:center">通孔覆盖合并</th><th style="text-align:center">全金属填充</th></tr></thead><tbody><tr><td style="text-align:center"><img src="mom-simulation/original-layout.png" alt="original-layout"></td><td style="text-align:center"><img src="mom-simulation/via-fill-layout.png" alt="via-fill-layout" style="zoom:80%;"></td><td style="text-align:center"><img src="mom-simulation/all-fill-layout.png" alt="all-fill-layout"></td></tr><tr><td style="text-align:center"><img src="mom-simulation/original.png" alt="original-id"></td><td style="text-align:center"><img src="mom-simulation/via-fill.png" alt="via-fill-id"></td><td style="text-align:center"><img src="mom-simulation/all-fill.png" alt="all-fill-id"></td></tr><tr><td style="text-align:center"><img src="mom-simulation/original-fill-i.png" alt="original-fill-i"></td><td style="text-align:center"><img src="mom-simulation/via-fill-i.png" alt="via-fill-i"></td><td style="text-align:center"><img src="mom-simulation/all-fill-i.png" alt="all-fill-i"></td></tr></tbody></table></div><p>可以看出，全金属填充方法会导致下层金属电流密度提升，从而提高了有效电容值。同时，其边缘产生了明显的横向电流和纵向电流，等效Q值也明显提高。因此，为了得到比较精准地结果，不建议将通孔填充到金属边缘，而应采用刚好覆盖原通孔的填充方式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文比较了几种电容的仿真方法。为了快速、准确地仿真电容，最好采用带有Edge Mesh的RF模式，通过通孔覆盖的方法合并通孔，同时降低通孔电导率至约1/5，并选择2D模型抑制水平电流。</p>]]></content>
      
      
      
        <tags>
            
            <tag> RFIC </tag>
            
            <tag> Capacitor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用ADS创建MOM电容Pcell</title>
      <link href="/archives/97db45b0/ads-mom-pcell.html"/>
      <url>/archives/97db45b0/ads-mom-pcell.html</url>
      
        <content type="html"><![CDATA[<p>在集成电路设计中，Pcell (Parameterized Cell)指只需要输入参数就可以通过程序代码自动创建的版图。例如，代工厂提供的工艺库中就含有常用的晶体管、电容以至电感的Pcell文件，在版图设计时只需要指定一些参数（在晶体管设计中例如栅长、栅宽、栅指数等）即可自动生成对应的版图。这极大简化了设计流程，缩短了设计周期。</p><p>然而，代工厂提供的预设工艺库有时可能不能满足设计要求。比如说，用户可能想设计一系列更高Q值，但精度较低的fringe电容，而工艺库却没有提供。此时，自定义Pcell可以省去重复设计的麻烦。常用的设计软件如Cadence、ADS都支持通过相应的编程语言（SKILL和AEL）自定义创建Pcell。</p><p>此外，也可以自行撰写脚本文件（例如Python），生成EGS格式的版图并导入ADS。使用这种方法时，也可以通过ADS的命令行工具进行批量仿真，十分方便。自行撰写脚本文件比较通用，可操控性强，但需要大量的编程工作（编写基础的图形类库）。</p><p>由于ADS集成了Momentum电磁场仿真软件，并支持通过自带的AMC (Advanced Model Composer)对Pcell进行自动仿真和建模，在设计中应用较为广泛。本文以电容设计为例，介绍了基于ADS的AEL语言的Pcell设计和批量仿真建模。<br><a id="more"></a></p><h2 id="预备"><a href="#预备" class="headerlink" title="预备"></a>预备</h2><p>这一部分介绍了一些预备知识。</p><h3 id="电容"><a href="#电容" class="headerlink" title="电容"></a>电容</h3><p>电容是射频集成电路设计必不可少的组件。它可以构成LC谐振网络，提供交流耦合、直流阻断。常见的电容类型有晶体管电容、二极管电容、MIM（Metal-Insulator-Metal）电容以及MOM（Metal-Oxide-Metal）电容。由于栅氧较薄，晶体管电容面积紧凑，但存在电压调制效应。就MIM和MOM而言，虽然Oxide也是一种Insulator，但MOM电容通常指代同层两个金属插指之间和其间氧化物形成的电容，而MIM以平板电容为主，有时特指模拟/射频工艺中提供的额外提供两层金属间的电容。</p><p>电容的一个简单模型是RC并联网络，其等效R为：</p><script type="math/tex; mode=display">C=\frac{\mathrm{imag}(Y_{11})}{2\pi f}</script><p>其等效C为：</p><script type="math/tex; mode=display">R=\frac{1}{\mathrm{real}(Y_{11})}</script><p>品质因数定义为：</p><script type="math/tex; mode=display">Q=2\pi fRC=\frac{\mathrm{imag}(Y_{11})}{\mathrm{real}(Y_{11})}=-\frac{\mathrm{imag}(Z_{11})}{\mathrm{real}(Z_{11})}</script><p>但这个简单模型只能在工作频率附近的窄带使用，针对电容更宽带的建模则需要将电感考虑进去。此时，模型为：</p><p><img src=".\ads-mom-pcell\capacitor-model-rlc.gif" alt="real world capacitor model"></p><p>此时，直流电阻为：</p><script type="math/tex; mode=display">R_{DC}=R_{ESR}+R_{Leakage}</script><p>高频电阻为：</p><script type="math/tex; mode=display">R_{RF}=R_{ESR}</script><p>低频电抗为</p><script type="math/tex; mode=display">\mathrm{imag}(Z_{IN})=\omega L-\frac{\omega CR^2}{1+\omega^2C^2R^2}\approx\omega L</script><p>谐振频率（虚部为0）为：</p><script type="math/tex; mode=display">f_{resonate}=\frac{1}{2\pi}\sqrt{\frac{CR^2-L}{LC^2R^2}}</script><p>因此，可以将这些参数从仿真中提取出来。</p><p>关于MOM电容的版图，其既可以是简单的同层结构</p><p><img src=".\ads-mom-pcell\mom.png" alt="mom capacitor"></p><p>也可以是交错的立体结构。此时，其电容密度较大：</p><p><img src=".\ads-mom-pcell\fringe-cap.png" alt="fringe capacitor"></p><p>3D透视图如下：</p><p><img src="ads-mom-pcell/mom_cap.png" alt="3D mom capacitor"></p><h3 id="AEL语言"><a href="#AEL语言" class="headerlink" title="AEL语言"></a>AEL语言</h3><p>AEL（Application Extension Language）是Keysight公司开发的基于C语言的通用编程语言，可用于配置、扩展ADS设计环境。其与C语言的区别主要有：</p><ul><li>没有预处理，不支持#if, #ifdef, #ifndef, #endif, #define, #undef以及#include，但增加了load()函数用于代替#include</li><li>没有类型，变量声明使用decl，函数声明使用defun，函数可以在函数内定义</li><li>支持复数和列表，但没有结构</li><li>拥有变量回收机制</li></ul><p>其列表的语法为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decl a = <span class="built_in">list</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">decl b = <span class="built_in">list</span>(<span class="string">"hello"</span>, a[<span class="number">0</span>]);<span class="comment">//可以混合类型</span></span><br></pre></td></tr></table></figure><p>其数组语法为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">decl x = &#123;<span class="number">1</span>+<span class="number">2</span>i, <span class="number">3</span>+<span class="number">4</span>i, <span class="number">5</span>+<span class="number">6</span>i&#125;;</span><br><span class="line">decl y = [<span class="number">1</span>+<span class="number">2</span>i, <span class="number">3</span>+<span class="number">4</span>i, <span class="number">5</span>+<span class="number">6</span>i];<span class="comment">//&#123;&#125;和[]可以互换</span></span><br><span class="line">decl z = &#123;<span class="number">1</span>::<span class="number">10</span>);<span class="comment">//生成1-10的数组</span></span><br><span class="line">decl u = &#123;<span class="number">1</span>::<span class="number">0.5</span>::<span class="number">10</span>);<span class="comment">//生成1-10的数组，间隔0.5</span></span><br></pre></td></tr></table></figure><p>对于矩阵：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">decl m = &#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">2</span>&#125;,&#123;<span class="number">3</span>&#125;&#125;;</span><br><span class="line">decl n = [<span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>];<span class="comment">//两者相同，生成二维数组</span></span><br><span class="line">decl o = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line">decl p = [<span class="number">1</span>, <span class="number">2</span>; <span class="number">3</span>, <span class="number">4</span>];<span class="comment">//两者相同，生成二维数组(矩阵)</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"%s\n"</span>, identify_value(m));<span class="comment">//打印矩阵</span></span><br></pre></td></tr></table></figure><h3 id="AMC"><a href="#AMC" class="headerlink" title="AMC"></a>AMC</h3><p>AMC (Advanced Model Composer)可以用于无源器件的模型生成，它可以根据预设参数和频率范围对Pcell进行自适应EM仿真，并根据结果建立模型。对于没有仿到的点，也可以根据其算法进行插值，得到较为精确的结果。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现绘制电容的Pcell代码主要为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">load(<span class="string">"vias.ael"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a parallel lines</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// context: the design context</span></span><br><span class="line"><span class="comment">// layer: the layer number</span></span><br><span class="line"><span class="comment">// fingers: number of the lines</span></span><br><span class="line"><span class="comment">// length: length of the lines</span></span><br><span class="line"><span class="comment">// width: width of the lines</span></span><br><span class="line"><span class="comment">// space: space of the lines</span></span><br><span class="line"><span class="comment">// x: lower-left x coordinate of the shape</span></span><br><span class="line"><span class="comment">// y: lower-left y coordinate of the shape</span></span><br><span class="line"><span class="comment">// extension: extension of lines on vertical direction</span></span><br><span class="line"><span class="comment">// dummy_finger: number of unconnected lines at each side</span></span><br><span class="line"><span class="comment">// polar: direction of the extension (0 at bottom, 1 at top)</span></span><br><span class="line"></span><br><span class="line"><span class="function">defun <span class="title">create_plines</span><span class="params">(context, layer, fingers, length, width, space, extension, x, y, dummy_finger, polar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x = <span class="keyword">float</span>(x);</span><br><span class="line">y = <span class="keyword">float</span>(y);</span><br><span class="line">decl i;</span><br><span class="line">decl xpos = <span class="number">0</span>;</span><br><span class="line">polar = <span class="keyword">int</span>(polar);</span><br><span class="line">fingers = <span class="keyword">int</span>(fingers);</span><br><span class="line">dummy_finger = <span class="keyword">int</span>(dummy_finger);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;dummy_finger; i++)</span><br><span class="line">&#123;</span><br><span class="line">db_add_rectangle(context, layer, x+xpos, y+extension, x+xpos+width, y+extension+length);</span><br><span class="line">xpos += (width + space);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;fingers; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(polar == <span class="number">0</span>)</span><br><span class="line">db_add_rectangle(context, layer, x+xpos, y+<span class="number">0</span>, x+xpos+width, y+extension+length);</span><br><span class="line"><span class="keyword">if</span>(polar == <span class="number">1</span>)</span><br><span class="line">db_add_rectangle(context, layer, x+xpos, y+extension, x+xpos+width, y+<span class="number">2</span>*extension+length);</span><br><span class="line">xpos += (width + space);</span><br><span class="line">polar = <span class="number">1</span> - polar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;dummy_finger; i++)</span><br><span class="line">&#123;</span><br><span class="line">db_add_rectangle(context, layer, x+xpos, y+extension, x+xpos+width, y+extension+length);</span><br><span class="line">xpos += (width + space);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a mom capacitor</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// start_layer: the lowest layer number</span></span><br><span class="line"><span class="comment">// end_layer: the highest layer number</span></span><br><span class="line"><span class="comment">// fingers: number of the fingers</span></span><br><span class="line"><span class="comment">// length: length of the fingers</span></span><br><span class="line"><span class="comment">// width: width of the fingers</span></span><br><span class="line"><span class="comment">// space: space of the fingers</span></span><br><span class="line"><span class="comment">// x_extension: extension of via array</span></span><br><span class="line"><span class="comment">// y_extension: space of figner to via array</span></span><br><span class="line"><span class="comment">// via_height: height of the via, width is calculated</span></span><br><span class="line"><span class="comment">// dummy_finger: number of unconnected fingers at each side</span></span><br><span class="line"><span class="comment">// fringe: whether to create a fringe capacitor</span></span><br><span class="line"><span class="comment">// combine: whether to combine vias for simulation simplification</span></span><br><span class="line"></span><br><span class="line"><span class="function">defun <span class="title">mom_cap</span><span class="params">(start_layer, end_layer, fingers, length, width, space, x_extension, y_extension, via_height, dummy_finger, fringe, combine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">decl designContext = de_get_current_design_context();</span><br><span class="line">decl polar = <span class="number">0</span>;</span><br><span class="line">decl i = <span class="number">0</span>;</span><br><span class="line">fringe = <span class="keyword">int</span>(fringe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get layer IDs</span></span><br><span class="line">decl M7 = db_get_layerid(designContext, <span class="string">"M7"</span>, <span class="string">"drawing"</span>);</span><br><span class="line">decl M6 = db_get_layerid(designContext, <span class="string">"M6"</span>, <span class="string">"drawing"</span>);</span><br><span class="line">decl M5 = db_get_layerid(designContext, <span class="string">"M5"</span>, <span class="string">"drawing"</span>);</span><br><span class="line">decl M4 = db_get_layerid(designContext, <span class="string">"M4"</span>, <span class="string">"drawing"</span>);</span><br><span class="line">decl M3 = db_get_layerid(designContext, <span class="string">"M3"</span>, <span class="string">"drawing"</span>);</span><br><span class="line">decl M2 = db_get_layerid(designContext, <span class="string">"M2"</span>, <span class="string">"drawing"</span>);</span><br><span class="line">decl M1 = db_get_layerid(designContext, <span class="string">"M1"</span>, <span class="string">"drawing"</span>);</span><br><span class="line">decl Metals = <span class="built_in">list</span>(M1, M1, M2, M3, M4, M5, M6, M7);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate the width of the via array</span></span><br><span class="line">decl t_width = <span class="number">2</span> * x_extension + space * (<span class="number">2</span>*dummy_finger + fingers - <span class="number">1</span>) + width * (<span class="number">2</span>*dummy_finger + fingers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create pins</span></span><br><span class="line">db_create_pin(designContext, t_width/<span class="number">2</span>, <span class="number">0</span>, <span class="number">-90</span>, Metals[end_layer], <span class="number">1</span>);</span><br><span class="line">db_create_pin(designContext, t_width/<span class="number">2</span>, <span class="number">2</span>*via_height+<span class="number">2</span>*y_extension+length, <span class="number">90</span>, Metals[end_layer], <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// create vias at two terminals</span></span><br><span class="line">via_fillto7(start_layer, end_layer, t_width, via_height, <span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0</span>, <span class="number">0</span>, combine);</span><br><span class="line">via_fillto7(start_layer, end_layer, t_width, via_height, <span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0</span>, via_height+<span class="number">2</span>*y_extension+length, combine);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// create lines for M1 to M7</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(start_layer &lt;= i &amp;&amp; end_layer &gt;= i)</span><br><span class="line">            &#123;</span><br><span class="line">                create_plines(designContext, Metals[i], fingers, length, width, space, y_extension, x_extension, via_height, dummy_finger, polar);</span><br><span class="line">                polar = fringe - polar;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A function wrapper</span></span><br><span class="line"><span class="function">defun <span class="title">mom_cap_wrapper</span><span class="params">(start_layer, end_layer, fingers, length, width, space, x_extension, y_extension, via_height, dummy_finger, fringe, combine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">decl designContext = de_get_current_design_context();</span><br><span class="line"></span><br><span class="line">decl mks2uu = db_get_mks_to_uu_factor(designContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert the units</span></span><br><span class="line">length = length * mks2uu;</span><br><span class="line">width = width * mks2uu;</span><br><span class="line">space = space * mks2uu;</span><br><span class="line">x_extension = x_extension * mks2uu;</span><br><span class="line">y_extension = y_extension * mks2uu;</span><br><span class="line">via_height = via_height * mks2uu;</span><br><span class="line"></span><br><span class="line">mom_cap(start_layer, end_layer, fingers, length, width, space, x_extension, y_extension, via_height, dummy_finger, fringe, combine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h3><p>为了运行代码，需要在ADS中进行一系列设置：</p><ol><li><p>在ADS库目录下新建mom.ael文件，加入上述代码；</p></li><li><p>在ADS库目录下新建eesof_lib.cfg文件，加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOT_AEL=./mom.ael</span><br></pre></td></tr></table></figure><p>此时，当ADS载入库时，代码会自动加载。为了强制重载，可以点击 File &gt; Recent Workspaces中这个库的名字；</p></li><li><p>新建一个空白layout，命名为momcap，点击File &gt; Design parameters，在其中设置各个参数的名称、类型、默认值、单位和描述。设置完成后点击确认。</p><p><img src="ads-mom-pcell/design-parameters.png" alt="set design parameters"></p><p>点击File &gt; Customize PCell，选择artwork类型为”AEL Macro“，将函数名写为主函数名。设置完成后点击确认。</p><p><img src="ads-mom-pcell/customize-pcell.png" alt="customize pcell"></p><p>保存layout；</p></li><li><p>另建一个名为momcap_sweep的layout，拖入刚才创建的momcap。此时应该出现默认值下的电容图形。在两端加上pin并设置好EM仿真。在EM &gt; Component &gt; Parameters中设置要扫描的变量名和范围（只能设置两个连续型变量），并将变量名填入Pcell的参数中。在EM &gt; Component &gt; Advanced Model Composer &gt; Create Model中开始仿真；</p></li><li><p>仿真结束后，点击EM &gt; Component &gt; Create EM Model and Symbol，在新建的原理图中加入symbol，设置好参数即可进行电路仿真。</p></li></ol><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>首先对插指长度进行扫描，绘制了等效电容和等效Q值的曲线：</p><p><img src="ads-mom-pcell/sweep_length_Q.png" alt="sweep_length_Q"></p><p>事实上，AMC并没有对8-25 um区间范围内的每个点进行仿真，而是在之前仿真结果的基础上进行插值，因为仿真速度非常快，适用于快速迭代和自动优化。仿真结果较为精确。</p><p>当观察28 GHz处的等效电容时随插指长变化时，有：</p><p><img src="ads-mom-pcell/sweep_length.png" alt="sweep_length"></p><p>当观察28 GHz处的等效电容时随插指数变化时，有：</p><p><img src="ads-mom-pcell/sweep_fingers.png" alt="sweep_fingers"></p><p>可以发现，在28 GHz处电容值基本随插指长、插指数而线性变化，因而实际设计时可以通过长度、插指数进行估算，进一步节省时间。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>Keysight, <em>Advanced Design System Documentation</em></li><li>Behzard Razavi, <em>RF Microelectronics</em></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> RFIC </tag>
            
            <tag> Capacitor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Diffucult Sentences in GRE Preparation</title>
      <link href="/archives/97db45b9/difficult-sentences.html"/>
      <url>/archives/97db45b9/difficult-sentences.html</url>
      
        <content type="html"><![CDATA[<p>All these sentences are picked from relevant GRE preparation books.</p><p>Excessive secrecy tends to <strong>invite</strong> excessive curiosity and thus serves to <strong>provoke</strong> the very impulses against which it guards.</p><p>Prudery actually draws attention to the vice that it is supposed to <strong>suppress</strong>; the very act that forbids the speech or prohibits sight <strong>dramatizes</strong> what is hidden.</p><p>Although Caroline Gordon was rigorously objective in her journalistic writing, her lively and <strong>exuberant</strong> private correspondence <strong>exhibited</strong> a delightful capacity for biting commentary on the social scene.<br><a id="more"></a></p><p>It would be a waste of time for any reviewer to bother <strong>condemning</strong> a book whose utter worthlessness is <strong>obvious</strong> to even the least discerning reader.</p><p>It would be misleading to use a published play to generalize about fifteenth-century drama; the very fact of publication should serve as a <strong>warning</strong> of the play’s <strong>unrepresentative</strong> character.</p><p>It is his dubious distinction to have proved what nobody would think of denying, that Romeo at the age of sixty-four writes with all the characteristic of <strong>maturity</strong>.</p><p>It is strange how words shape our thoughts and trap us at the bottom of deeply <strong>incised</strong> canyon of thinking, their imprisoning sides carved out by the <strong>river</strong> of past usage.</p><p>It is ironic that a critic of such overwhelming vanity now suffers from a measure of oblivion to which he was forever <strong>consigning</strong> others, in the end, all his <strong>self-adulation</strong> has only worked against him.</p><p>People should not be praised for their virtue if they lacked the energy to be <strong>wicked</strong>; in such cases, goodness is merely the effect of <strong>indolence</strong>.</p><p>Observable as a tendency of our culture is a <strong>withdrawal</strong> of <strong>belief</strong> in psychoanalysis: we no longer feel that it can solve our emotional problems.</p><p>Broadway audiences have been inured to <strong>mediocrity</strong> and so <strong>desperate</strong> to be pleased as to make their ready ovations meaningless as an indicator of the quality of the production before them.</p><p>Without seeming unworldly, William James appeared wholly removed from the <strong>commonplace</strong> of the society, the conventionality of academe.</p><p>Any language is a conspiracy against experience in the sense that it is a collective attempt to <strong>manage</strong> experience by reducing it into discrete parcels.</p><p>There is perhaps some truth in that waggish old definition of scholar - a siren that calls attention to a fog without doing anything to <strong>dispel</strong> it.</p><p>We realized that John was still young and impressionable, but were nevertheless surprised at his <strong>naivete</strong>. </p><p>The First World War began in a context of jargon and verbal delicacy and continued in a cloud of <strong>euphemism</strong> as <strong>impenetrable</strong> as language and literature, skillfully used, could make it.</p><p>Noting the murder victim’s flaccid musculature and pear-like figure, she deduced that the unfortunate fellow had earned his living in some <strong>sedentary</strong> occupation.</p><p>Politeness is not a <strong>superficial</strong> attribute of human behavior, but a rather a central virtue, one whose very existence is increasingly being <strong>threatened</strong> by the faddish requirement to “speak one’s mind”.</p><p>Ever prey to vagrant impulses that impelled him to <strong>squander</strong> his talents on a host of unworthy projects, his very <strong>dissipation</strong> nonetheless enhanced his reputation, for the sheer energy of his extravagance dazzled observers.</p><p>While some see in practical jokes a wish for mastery in miniature over a world that seems very <strong>unruly</strong>, others believe that the joke’s purpose is to disrupt, by reducing all transactions to <strong>chaos</strong>.</p><p>For all his <strong>boorishness</strong>, Honore de Balzac betrayed a remarkable <strong>sensitivity</strong> to the plight of 19th century women, populating his novel with characters sympathetic to women’s right.</p><p>Inspired interim responses to hitherto unknown problems, New Deal economic stratagems became <strong>ossified</strong> as a result of bureaucratization, their flexibility and adaptability destroyed by their transformation into rigid policies.</p><p>The architects of New York’s early skyscrapers, hinting here at a twelfth-century cathedral, there at a fifteenth-century palace, sought to legitimize the city’s social striving by <strong>evoke</strong> a history the city did not truly <strong>possess</strong>.</p><p>Ethologists are convinced that many animals survive through learning - but learning that is <strong>dictated by</strong> their generic programming, learning as throughly <strong>stereotyped</strong> as the most instinctive of behavioral responses.</p><p>The senator’s reputation, though <strong>shaken</strong> by false allegations of misconduct, emerged from the ordeal <strong>unscathed</strong>.</p><p>A human being is quite <strong>frail</strong> creature, for the gloss of rationality that covers his or her fears and <strong>insecurity</strong> is thin and easily breached.</p><p>The <strong>deference</strong> with which the French aristocracy greeted the middle-class Rousseau was all the more <strong>remarkable</strong> because he showed so little respect for them.</p><p>The influence of the Titnaeus among early philosophical thinkers was <strong>pervasive</strong>, if only because it was the sole dialogue <strong>available</strong> in Europe for almost 1000 years.</p><p>The Gibsons were little given to <strong>conformism</strong> in any form; not one of them was afraid of <strong>singularity</strong>, of being seeming unlike their neighbors.</p><p>Salazar’s presence in the group was so <strong>reassuring</strong> to the others that they lost most of their earlier <strong>trepidation</strong>; failure, for them, became all but unthinkable.</p><p><em>all but = almost, anything but = not at all</em></p><p>Read‘s apology to Heflin was not exactly abject and did little to <strong>resolve</strong> their decades-long quarrel, which had been as <strong>acrimonious</strong> as the academic etiquette of scholarly journals permitted.</p><p>An obvious style, easily identified by some superficial quirk, is properly <strong>decried</strong> as a mere mannerism, whereas a complex and subtle style <strong>resists</strong> reduction to a formula.</p><p>Jones was unable to recognize, the contradictions in his attitudes that were obvious to everyone else; even the hint of an untruth was <strong>repugnant</strong> to him, but he <strong>courted</strong> serious trouble by always cheating on his taxes.</p><p>The idea of an autonomous discipline called “philosophy,” distinct from and sitting in judgment on such pursuits as theology and science turns out, on close examination, to be of quite recent origin.</p><p>She writes across generational lines, making the past so <strong>vivid</strong> that our belief that the present is the true locus of experience is undermined.</p><p>The trick for Michael was to <strong>conjure for</strong> his son a illusory orderliness; only alone at night, when the boy was asleep, could Michael <strong>acknowledge</strong> the chaos he kept hidden from his son.</p><p>The current demand for quality in the schools seems to ask not for the development of informed and active citizens, but for disciplined and productive workers with abilities that contribute to civic life only <strong>indirectly</strong>, if at all.</p><p>Bob: It seems like this city is getting more dangerous every day.</p><p>Steve: Actually, it doesn’t seem that much worse from when I first moved here. If anything, the crime rate has actually dropped since the city’s population has almost doubled in the last ten years.</p><p>Carruther‘s latest literature criticism <strong>belies</strong> her reputation for trenchant commentary; despite its intriguing titles and the fulsome praise on its dust jacket, it is nothing more than a collection of <strong>platitudes</strong>.</p><p><em>belie: contradict</em></p><p>Those who fear the influence of television deliberately <strong>underplay</strong> its persuasive power, hoping that they might keep knowledge of its potential to effect social change from being widely disseminated.</p><p>Far from being <strong>unctuous</strong>, Pat was always loath to appear <strong>acquiescent</strong>.</p><p>A desire to throw over reality a light that never was might give away abruptly to the desire on the part of what we might consider a novelist-scientist to record exactly and concretely the structure and texture of a flower</p><p>It has thus generally been by way of the emphasis on oral literary creativity that these Chicano writers, whose English-language works are sometimes uninspired, developed the powerful and arresting language that characterized their Spanish-language works.</p><p>Having no sense of moral obligation, Shipler was as little subject to the <strong>reproach</strong> of conscience after he acted as he was motivated by its <strong>promptings</strong> before he acted.</p><p>Only in the case of the February Revolution do we lack a useful description of participants that might characterize it in the light of what social history has taught us about the process of revolutionary mobilization.</p><p>She was criticized by her fellow lawyers not because she was not <strong>hardworking</strong>, but because she so <strong>minutely</strong> prepared her cases that she failed to bring the expected number to trial.</p><p>Religious philosopher that he was, Henry More derived his conception of an infinite universe from the Infinite God in whom he believed, a benevolent God of <strong>plenitude</strong> whose nature was to create <strong>abundance</strong>.</p><p>The author, mocked by many for his simple, almost childlike prose, can at least not be begrudged the distinction of writing with <strong>lucidness</strong>.</p><p><em>begrudge: give unwillingly</em></p><p>Perhaps there is nothing more to the album than its case that experimentalism into uncharted sonic landscapes did not <strong>die</strong> with Stockhausen. Or perhaps its forays—many of which could rightly be dubbed sophomoric—into the avant-grade also lead to the <strong>unsettling conclusion</strong> that to create an unprecedented sound one has to <strong>forgo producing</strong> a discernible melody.</p><p>There’s hardly a generalization that can be made about people’s social behavior and the values informing it that cannot be <strong>challenged</strong> from one or another point of view, or even <strong>dismissed</strong> as simplistic or vapid.</p>]]></content>
      
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to Model RLGC Transmission Line</title>
      <link href="/archives/afb86e77/transmission-line.html"/>
      <url>/archives/afb86e77/transmission-line.html</url>
      
        <content type="html"><![CDATA[<p>This paper details the equations of transmission line, and introduces how to use Matlab to model RLGC transmission line.</p><a id="more"></a><h2 id="Transmission-Line"><a href="#Transmission-Line" class="headerlink" title="Transmission Line"></a>Transmission Line</h2><h3 id="Transmission-Line-Solutions"><a href="#Transmission-Line-Solutions" class="headerlink" title="Transmission Line Solutions"></a>Transmission Line Solutions</h3><p><img src="transmission-line\transmission-line-schematic.png" alt="transmission-line-schematic"></p><p>Basic transmission line solution are</p><script type="math/tex; mode=display">V(z)=V^+e^{-\gamma z}+V^-e^{\gamma z}</script><script type="math/tex; mode=display">I(z)=I^+e^{-\gamma z}-I^-e^{\gamma z}</script><p>with</p><script type="math/tex; mode=display">\frac{V^+}{I^+}=\frac{V^-}{I^-}=Z_0</script><p>Since</p><script type="math/tex; mode=display">Z_L=\frac{V(0)}{I(0)}=\frac{V^++V^-}{V^+-V^-}Z_0</script><p>we can get</p><script type="math/tex; mode=display">\Gamma=\frac{V^-}{V^+}=\frac{Z_L-Z_0}{Z_L+Z_0}</script><p>and</p><script type="math/tex; mode=display">\operatorname{SWR}=\frac{1+|\Gamma|}{1-|\Gamma|}</script><p>At arbitrary point, the reflection coefficient is</p><script type="math/tex; mode=display">\Gamma(l)=\frac{V^-e^{-j\beta l}}{V^+e^{j\beta l}}=\Gamma(0)e^{-2j\beta l}</script><p>and input impedance is</p><script type="math/tex; mode=display">Z_{in}=Z_0\frac{Z_L+jZ_0\tan{\beta l}}{Z_0+jZ_L\tan{\beta l}}</script><p>Thus</p><ul><li><p>For a <strong>quarter-wavelength</strong> transmission line where $\beta l=\pi/4$, we have</p><script type="math/tex; mode=display">Z_{in}Z_L=Z_0^2</script></li><li><p>An <strong>open</strong> stub where $Z_L=\infty$</p><script type="math/tex; mode=display">Z_{in}=-jZ_0\cot{\beta l}</script></li><li><p>An <strong>short</strong> stub where $Z_l=0$</p><script type="math/tex; mode=display">Z_{in}=jZ_0\tan{\beta l}</script></li></ul><p>This part deals with the conversion between RLGC parameters and the $\gamma$ Z parameters.</p><h3 id="Parameter-Conversion"><a href="#Parameter-Conversion" class="headerlink" title="Parameter Conversion"></a>Parameter Conversion</h3><p>RLCG to $\gamma$ Z</p><script type="math/tex; mode=display">\gamma=\sqrt{(R+j\omega L)(G+j\omega C)}=\alpha+j\beta</script><script type="math/tex; mode=display">Z=\sqrt{\frac{R+j\omega L}{G+j\omega C}}</script><p>$\gamma$ Z to RLCG</p><script type="math/tex; mode=display">R={\rm Re}\{\gamma Z\}</script><script type="math/tex; mode=display">L={\rm Im}\{\gamma Z\}/\omega</script><script type="math/tex; mode=display">G={\rm Re}\{\gamma/Z\}</script><script type="math/tex; mode=display">C={\rm Im}\{\gamma/Z\}/\omega</script><h2 id="Obtain-Z-and-gamma-from-simulation"><a href="#Obtain-Z-and-gamma-from-simulation" class="headerlink" title="Obtain Z and $\gamma$ from simulation"></a>Obtain Z and $\gamma$ from simulation</h2><p><img src="transmission-line/simulation_schematic.png" alt="simulation_schematic"></p><p>Real part of characteristic impedance is given by</p><p><img src="transmission-line/real_of_Z.png" alt="real_of_Z"></p><h2 id="Use-Matlab-to-obtain-RLGC-Z-and-gamma"><a href="#Use-Matlab-to-obtain-RLGC-Z-and-gamma" class="headerlink" title="Use Matlab to obtain RLGC, Z and $\gamma$"></a>Use Matlab to obtain RLGC, Z and $\gamma$</h2><h3 id="Calculation"><a href="#Calculation" class="headerlink" title="Calculation"></a>Calculation</h3><p>MATLAB code</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PolartoComplex = @(len, the) len*<span class="built_in">cos</span>(the*<span class="built_in">pi</span>/<span class="number">180</span>) + <span class="number">1</span><span class="built_in">i</span>*len*<span class="built_in">sin</span>(the*<span class="built_in">pi</span>/<span class="number">180</span>);</span><br><span class="line"></span><br><span class="line">S11 = PolartoComplex(<span class="number">0.019</span>, <span class="number">9.658</span>);</span><br><span class="line">S12 = PolartoComplex(<span class="number">0.975</span>, <span class="number">-28.942</span>);</span><br><span class="line">S21 = PolartoComplex(<span class="number">0.975</span>, <span class="number">-28.942</span>);</span><br><span class="line">S22 = PolartoComplex(<span class="number">0.019</span>, <span class="number">9.658</span>);</span><br><span class="line"><span class="built_in">length</span> = <span class="number">400e-6</span>;<span class="comment">% length of transmission line</span></span><br><span class="line">freq = <span class="number">28e9</span>;<span class="comment">% frequency of simulation</span></span><br><span class="line">Z0 = <span class="number">50</span>;</span><br><span class="line">rlgc_params = s2rlgc([S11, S12; S21, S22], <span class="built_in">length</span>, freq, Z0)</span><br></pre></td></tr></table></figure><p>Corresponding output is</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    R: 5.1717e+03</span><br><span class="line">    L: 3.6799e-07</span><br><span class="line">    G: 0.4737</span><br><span class="line">    C: 1.4002e-10</span><br><span class="line">alpha: 62.5539</span><br><span class="line"> beta: 1.2634e+03</span><br><span class="line">   Zc: 51.3183 - 1.5526i</span><br></pre></td></tr></table></figure><h3 id="Verification"><a href="#Verification" class="headerlink" title="Verification"></a>Verification</h3><p>Using 8 RLGC segments</p><p><img src="transmission-line/lumped_mimic_distributed.png" alt="lumped_mimic_distributed"></p><p>Detailed schematic of each one</p><p><img src="transmission-line/detailed_schematic.png" alt="detailed_schematic"></p><p>Results</p><p><img src="transmission-line/simulation_result.png" alt="simulation_result"></p><h2 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h2><ol><li><p>How to convert $\alpha, \beta$ parameters to $A, \epsilon$ parameters?</p><script type="math/tex; mode=display">\beta=\omega\sqrt{\mu\epsilon}=\omega\sqrt{\mu_0\epsilon_0\epsilon_{eff}}</script><script type="math/tex; mode=display">1\ NP/m=20\log_{10}{e^{1}}=8.686\ dB/m</script><script type="math/tex; mode=display">A=20\alpha\log_{10}{e}</script><script type="math/tex; mode=display">\epsilon_{eff}=\left(\frac{c\beta}{\omega}\right)^2</script></li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li>W. R. Eisenstadt and Y. Eo, “S-parameter-based IC interconnect transmission line characterization,” in <em>IEEE Transactions on Components, Hybrids, and Manufacturing Technology</em>, vol. 15, no. 4, pp. 483-490, Aug. 1992. DOI:  <a href="https://doi.org/10.1109/33.159877" target="_blank" rel="noopener">10.1109/33.159877</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> RFIC </tag>
            
            <tag> Transmission Line </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
